---
/**
 * CLS-safe Image Modal
 * - Uses opacity + pointer-events instead of removing from layout to prevent scroll jumps.
 * - Locks body scroll without shifting content (compensates scrollbar width).
 * - Adds smooth fade-in/out transitions.
 */
---
<style>
  #img-modal {
    transition: opacity 0.25s ease;
  }
  #img-modal.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #img-modal.visible {
    opacity: 1;
    pointer-events: auto;
  }
</style>

<div
  id="img-modal"
  class="fixed inset-0 z-[1000] hidden opacity-0"
  aria-hidden="true"
>
  <!-- Overlay -->
  <div
    id="img-modal-overlay"
    class="absolute inset-0 bg-black/80 backdrop-blur-sm transition-opacity duration-300"
  ></div>

  <!-- Close -->
  <button
    id="img-modal-close"
    aria-label="Close"
    class="absolute top-4 right-4 bg-white/10 hover:bg-white/20 text-white px-3 py-1 rounded-xl backdrop-blur transition-opacity duration-200"
    data-close
  >
    Close
  </button>

  <!-- Image area -->
  <div class="relative h-full w-full flex items-center justify-center p-4">
    <img
      id="img-modal-image"
      alt="Expanded view"
      loading="lazy"
      decoding="async"
      class="max-h-full max-w-full rounded-xl shadow-2xl border border-white/10 pointer-events-auto transition-transform duration-300 will-change-transform"
    />
  </div>
</div>

<script is:inline>
  (() => {
    const modal = document.getElementById('img-modal');
    const overlay = document.getElementById('img-modal-overlay');
    const imgEl = document.getElementById('img-modal-image');

    let scrollBarWidth = 0;

    // Calculate scrollbar width once
    function getScrollbarWidth() {
      const div = document.createElement('div');
      div.style.visibility = 'hidden';
      div.style.overflow = 'scroll';
      div.style.width = '50px';
      div.style.height = '50px';
      document.body.appendChild(div);
      const inner = document.createElement('div');
      inner.style.width = '100%';
      div.appendChild(inner);
      const width = div.offsetWidth - inner.offsetWidth;
      div.remove();
      return width;
    }

    scrollBarWidth = getScrollbarWidth();

    function openModal(src) {
      if (!src) return;
      imgEl.src = src;
      modal.classList.remove('hidden');
      modal.classList.add('visible');
      modal.setAttribute('aria-hidden', 'false');

      // Prevent scroll shift when hiding scrollbar
      document.body.style.overflow = 'hidden';
      document.body.style.paddingRight = scrollBarWidth + 'px';
    }

    function closeModal() {
      modal.classList.remove('visible');
      modal.classList.add('hidden');
      modal.setAttribute('aria-hidden', 'true');

      // Allow scrolling again
      document.body.style.overflow = '';
      document.body.style.paddingRight = '';
      imgEl.removeAttribute('src');
    }

    // Open any element with [data-zoom]
    document.addEventListener('click', (e) => {
      const zoomTarget = e.target.closest('[data-zoom]');
      if (zoomTarget) {
        const src =
          zoomTarget.getAttribute('data-src') ||
          zoomTarget.getAttribute('src');
        openModal(src);
      }
    });

    // Close on overlay or button
    document.addEventListener('click', (e) => {
      if (modal.classList.contains('hidden')) return;

      const isCloseBtn = e.target.closest('[data-close]');
      const clickedOverlay = e.target === overlay;

      if (isCloseBtn || clickedOverlay) {
        closeModal();
      }
    });

    // Esc key closes
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.classList.contains('visible')) {
        closeModal();
      }
    });
  })();
</script>
